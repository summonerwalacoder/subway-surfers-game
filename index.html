<!DOCTYPE html>
<html>
<head>
    <title>Subway Surfer: Hall of Fame</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        canvas { display: block; margin: auto; background: linear-gradient(#0f0c29, #302b63, #24243e); }
        #ui { position: absolute; top: 10px; width: 100%; text-align: center; color: white; pointer-events: none; }
        .score { font-size: 32px; font-weight: bold; color: #f1c40f; }
        .high-score { font-size: 18px; color: #00ffcc; margin-top: 5px; }
        #powerup-text { font-size: 18px; color: #ff4444; font-weight: bold; margin-top: 10px; }
    </style>
</head>
<body>
    <div id="ui">
        <div class="score">SCORE: <span id="score">0</span></div>
        <div class="high-score">BEST: <span id="best">0</span></div>
        <div id="powerup-text"></div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = Math.min(window.innerWidth, 400);
canvas.height = window.innerHeight;

// Load High Score from Browser Memory
let highScore = localStorage.getItem("subwayBest") || 0;
document.getElementById("best").innerText = highScore;

let score = 0, gameActive = true, speed = 8;
let playerLane = 1;
const lanes = [canvas.width * 0.2, canvas.width * 0.5, canvas.width * 0.8];

const player = {
    x: lanes[1], y: canvas.height - 150, jumpY: 0,
    isJumping: false, jumpVelocity: 0,
    magnetTimer: 0, flightTimer: 0
};

let objects = [];

// Input Listeners
window.addEventListener("keydown", e => {
    if (e.key === "ArrowLeft" && playerLane > 0) playerLane--;
    if (e.key === "ArrowRight" && playerLane < 2) playerLane++;
    if ((e.key === " " || e.key === "ArrowUp") && player.flightTimer <= 0) jump();
});

let touchStart = { x: 0, y: 0 };
window.addEventListener("touchstart", e => { touchStart.x = e.touches[0].clientX; touchStart.y = e.touches[0].clientY; });
window.addEventListener("touchend", e => {
    let dx = e.changedTouches[0].clientX - touchStart.x;
    let dy = e.changedTouches[0].clientY - touchStart.y;
    if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 30 && playerLane < 2) playerLane++;
        else if (dx < -30 && playerLane > 0) playerLane--;
    } else { if (dy < -30 && player.flightTimer <= 0) jump(); }
});

function jump() {
    if (!player.isJumping) { player.isJumping = true; player.jumpVelocity = 16; }
}

function spawn() {
    if (!gameActive) return;
    const lane = Math.floor(Math.random() * 3);
    const rand = Math.random();
    let type = 'train';
    if (player.flightTimer > 0) type = 'coin';
    else {
        if (rand < 0.15) type = 'coin';
        else if (rand < 0.17) type = 'magnet';
        else if (rand < 0.19) type = 'carpet';
    }
    objects.push({ x: lanes[lane], y: -50, type: type });
    setTimeout(spawn, player.flightTimer > 0 ? 150 : Math.max(300, 1000 - speed * 30));
}

function update() {
    if (!gameActive) return;
    score++;
    speed += 0.002;
    
    let currentScore = Math.floor(score/10);
    document.getElementById("score").innerText = currentScore;

    if (player.magnetTimer > 0) player.magnetTimer--;
    if (player.flightTimer > 0) player.flightTimer--;

    // Physics
    if (player.flightTimer > 0) {
        player.jumpY += (180 - player.jumpY) * 0.1;
    } else if (player.isJumping) {
        player.jumpY += player.jumpVelocity;
        player.jumpVelocity -= 0.8;
        if (player.jumpY <= 0) { player.jumpY = 0; player.isJumping = false; }
    } else {
        player.jumpY += (0 - player.jumpY) * 0.1;
    }

    player.x += (lanes[playerLane] - player.x) * 0.2;

    objects.forEach((obj, i) => {
        obj.y += speed;
        if (player.magnetTimer > 0 && obj.type === 'coin') {
            obj.x += (player.x - obj.x) * 0.2;
            obj.y += (player.y - player.jumpY - obj.y) * 0.2;
        }

        let dist = Math.hypot(obj.x - player.x, obj.y - (player.y - player.jumpY));
        if (dist < 45) {
            if (obj.type === 'train' && player.jumpY < 50) {
                endGame(currentScore);
            } else if (obj.type === 'coin') {
                score += 1000;
                objects.splice(i, 1);
            } else if (obj.type === 'magnet') {
                player.magnetTimer = 500;
                objects.splice(i, 1);
            } else if (obj.type === 'carpet') {
                player.flightTimer = 400;
                objects.splice(i, 1);
            }
        }
        if (obj.y > canvas.height + 100) objects.splice(i, 1);
    });
}

function endGame(finalScore) {
    gameActive = false;
    // Save New High Score
    if (finalScore > highScore) {
        localStorage.setItem("subwayBest", finalScore);
        alert("NEW HIGH SCORE: " + finalScore + "! üèÜ");
    } else {
        alert("BUSTED! Final Score: " + finalScore);
    }
    location.reload();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw Rails
    ctx.strokeStyle = "rgba(255,255,255,0.1)";
    lanes.forEach(lx => {
        ctx.lineWidth = 20;
        ctx.beginPath(); ctx.moveTo(lx, 0); ctx.lineTo(lx, canvas.height); ctx.stroke();
    });

    ctx.font = "40px serif";
    ctx.textAlign = "center";
    
    objects.forEach(obj => {
        let icon = obj.type === 'train' ? 'üöÜ' : obj.type === 'coin' ? 'üí∞' : obj.type === 'magnet' ? 'üß≤' : 'üõãÔ∏è';
        ctx.fillText(icon, obj.x, obj.y);
    });

    // Police Chase
    ctx.fillText('üëÆ‚Äç‚ôÇÔ∏è', player.x, player.y + 110);
    ctx.fillText('üêï', player.x - 40, player.y + 120);

    // Player
    if (player.flightTimer > 0) ctx.fillText('üõãÔ∏è', player.x, player.y - player.jumpY + 20);
    ctx.fillText('üèÉ‚Äç‚ôÇÔ∏è', player.x, player.y - player.jumpY);

    update();
    requestAnimationFrame(draw);
}

spawn();
draw();
</script>
</body>
</html>
